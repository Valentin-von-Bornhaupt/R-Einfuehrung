\section{For-Schleifen}
\label{sec:for-schleifen}
For-Schleifen helfen immens beim Automatisieren stupider Aufgaben: Dafür betrachten wir die Fibonacci-Zahlen (eingeführt in Kap. \ref{sec:VectorenSukzessivFuellen}) erneut. Dieses Mal bis zur siebten Zahl: 
<<>>=
FibonacciVektor = c() # Erstellt einen leeren Vektor
FibonacciVektor[1] = 1 # n = 1
FibonacciVektor[2] = 1 # n = 2
FibonacciVektor[3] = FibonacciVektor[2] + FibonacciVektor[1] # n = 3
FibonacciVektor[4] = FibonacciVektor[3] + FibonacciVektor[2] # n = 4
FibonacciVektor[5] = FibonacciVektor[4] + FibonacciVektor[3] # n = 5
FibonacciVektor[6] = FibonacciVektor[5] + FibonacciVektor[4] # n = 6
FibonacciVektor[7] = FibonacciVektor[6] + FibonacciVektor[5] # n = 7
FibonacciVektor
@
Das ist ziemlich viel \textit{stupide} Schreibarbeit, bei der sich in jeder Zeile nicht viel ändert. Wollten wir mit der Technik die 20. Fibonaccizahl errechnen, wären wir lange beschäftigt. Hier helfen \cl{for}-Schleifen:

<<eval = FALSE>>=
for (Variable in Vektor){
    Befehlsblock
}
@
Die \cl{Variable} nimmt dabei nacheinander alle Werte in dem \cl{Vektor} an. Für jeden Wert der Variable wird dann alles in dem \cl{Befehlsblock} einmal ausgeführt:

<<>>=
for (zahl in 2:7){
    print(zahl) # gebe Zahl aus
}
@

<<>>=
for (zahl in seq(0.5, 2, 0.5)){
    aktuellerWert = zahl^2 + 1
    print(aktuellerWert) # gebe Zahl aus
}
@

<<>>=
woerter = c("Mathe", "finde", "ich", "klasse")
for (wort in woerter){
    print(wort) # gebe Wort aus
}
@

Auch unser (am Anfang dieses Kapitels) motiviertes Problem der ersten 20 Fibonacci-Zahlen lässt sich mit for-Schleifen automatisieren:

<<>>=
FibonacciVektor = c() # Erstellt einen leeren Vektor
FibonacciVektor[1] = 1 # n = 1
FibonacciVektor[2] = 1 # n = 2
for(n in 3:20){
    FibonacciVektor[n] = FibonacciVektor[n-2] + FibonacciVektor[n-1]
}
FibonacciVektor
@

\begin{aufgabe}(Optional)\\
    Löse das Problem aus Kapitel \ref{sec:ifvektoren} mithilfe einer for-Schleife. D.h. schreibe ein kleines R-Skript mit einer for-Schleife, das prüfen soll, ob ein beliebig gefüllter Vektor namens \cl{xVec} mindestens einen positiven Eintrag hat. Falls Du einen Tipp brauchst, schaue in die Fußnote\footnote{Erstelle erst einmal eine Variable \cl{positivenWertGefunden = FALSE}. Beim Durchgehen der For-Schleife: Wann musst Du diese Variable auf \cl{TRUE} setzen?}.
\end{aufgabe}


\subsection{Geschwindigkeitsvergleich Vektorrechnung vs. for-Schleifen}
Durch den Einsatz von \cl{Vektorrechnung} (Siehe Kap. \ref{sec:Rechnen_mit_Vektoren}) (und Matrizenrechnung) lassen sich in R häufig for-Schleifen vermeiden. Vektorrechnungen funktionieren in R schneller als for-Schleifen, weshalb man Vektorrechnungen bevorzugen sollte, falls man die Wahl hat. Hier ein Beispiel, was den Zeitunterschied simulieren soll:
<<>>=
# der system.time(())-Befehl misst die Geschwinigkeit für uns:

# Berechnung mit Vektorrechnung
dauerFuerBerechnungVek = system.time((
    summeVektorrechnung = sum( (1 : 10000000)^2 )
))

# Berechnung mit for-Schleife
summeForSchleife = 0 
dauerFuerBerechnungFor = system.time(
    for(summand in 1 : 10000000) {
        summeForSchleife = summeForSchleife + summand^2
    }
)
# Gleiches Ergebnis bei beiden Berechnungen...
print(summeVektorrechnung)
print(summeForSchleife)
# ...in unterschiedlicher Zeit (siehe Sekunden in "user" - Spalte)
print(dauerFuerBerechnungVek)
print(dauerFuerBerechnungFor)

@
Falls Du Dich fragst, wie die Zeile \cl{summeForSchleife = summeForSchleife + summand \textasciicircum \, 2} innerhalb der For-Schleife genau funktioniert, gucke doch noch einmal im nächsten Abschnitt vorbei.

\subsection{Denken in for-Schleifen}
Im Vorherigen Kapitel haben wir uns nebenbei eine for-Schleife angesehen, die eine Summe von Quadratzahlen berechnen soll. Wir wollen uns die For-Schleife erneut im kleinen Rahmen ansehen. Weitere Informationen zum Überschreiben von Variablen findest Du in Kapitel \ref{sec:variablen_ueberschreiben}.
<<>>=
# Vor Beginn der Schleife:
zwischenergebnis = 0
# for-Schleifenkopf:
for (summand in -2 : 4){
    # Berechnung im {}-Block der for-Schleife:
    zwischenergebnis = zwischenergebnis + summand^2 
}
summe = zwischenergebnis # Nach dem Ende der for-Schleife
@
Wie funktioniert diese Berechnung? Was wird hier überhaupt berechnet? Im folgenden wollen wir uns einmal händisch ansehen, was der Computer in diesen paar Zeilen Code macht. Gleiche Farben stehen für gleiche Werte:
\begin{enumerate}
    \addtocounter{enumi}{-1}
    \item \textbf{Vor Beginn:} \colorbox{yellow}{zwischenergebnis = 0}
    \item \textbf{Schleifendurchgang:} \begin{enumerate}
        \item Setzen \cl{summand} auf den ersten Eintrag von \cl{-2 : 4} (d.h. -2):\\
        \colorbox{orange}{summand = -2}
        \item Rechnen 
            \begin{align*}
                \colorbox{pink}{zwischenergebnis} & = \colorbox{yellow}{\text{zwischenergebnis}} + \colorbox{orange}{\text{summand}}^2\\
                & = \colorbox{yellow}{0} + \colorbox{orange}{-2}^2\\
                & = \colorbox{pink}{4}
            \end{align*}
            $\implies$ \colorbox{pink}{zwischenergebnis = 4} (d.h. $0 + (-2)^2$)
    \end{enumerate}
    \item \textbf{Schleifendurchgang:}
    \begin{enumerate}
        \item Setzen \cl{summand} auf den nächsten Eintrag von \cl{-2 : 4} (d.h. -1):\\
        \colorbox{green}{summand = -1}
        \item Rechnen 
            \begin{align*}
                \colorbox{cyan}{zwischenergebnis} & = \colorbox{pink}{\text{zwischenergebnis}} + \colorbox{green}{\text{summand}}^2\\
                & = \colorbox{pink}{4} + \colorbox{green}{-1}^2\\
                & = \colorbox{cyan}{5}
            \end{align*}
            $\implies$ \colorbox{cyan}{zwischenergebnis = 5} (d.h. $0 + (-2)^2 + (-1)^2$)
    \end{enumerate}
    \item \textbf{Schleifendurchgang:}\\ 
    \begin{enumerate}
        \item Setzen \cl{summand} auf den nächsten Eintrag von \cl{-2 : 4} (d.h. 0):\\
        \colorbox{Lavender}{summand = 0}
        \item Rechnen 
            \begin{align*}
                \colorbox{lime}{zwischenergebnis} & = \colorbox{cyan}{\text{zwischenergebnis}} + \colorbox{Lavender}{\text{summand}}^2\\
                & = \colorbox{cyan}{5} + \colorbox{Lavender}{0}^2\\
                & = \colorbox{lime}{5}
            \end{align*}
            $\implies$ \colorbox{lime}{zwischenergebnis = 5} (d.h. $0 + (-2)^2 + (-1)^2 + 0^2$)
    \end{enumerate}
\end{enumerate}

\begin{aufgabe} \textbf{(Optional)}
    Denke den 4. Schleifendurchgang einmal selbst durch!
\end{aufgabe}

Wenn wir dieses Prozedere jetzt weiter denken, dann wird in der Variable \cl{zwischenergebnis} in jedem Schleifendurchgang genau ein quadrierter Summand mehr gespeichert. D.h. nach dem Beenden der for-Schleife (also nachdem \cl{summand} jeden Wert in dem Vektor \cl{ -2 : 4} angenommen hat) haben wir in der Variable \cl{zwischenergebnis} die komplette Summe gespeichert:
\begin{align*}
    % \cl{\text{zwischenergebnis}} = 0 + (-2)^2 + (-1)^2 + 0^2 + 1^2 + 2^2 + 3^2 + 4^2 = \sum_{i = -2}^4 i^2\\
    \cl{\text{summe}} = 
    \underbrace{
        \underbrace{
            \underbrace{
                \underbrace{    
                    \underbrace{
                        0}_{\colorbox{yellow}{zwischenergebnis = 0}
                    } 
                (-2)^2}_{\colorbox{pink}{zwischenergebnis = 4}
                } 
                + (-1)^2}_{\colorbox{cyan}{zwischenergebnis = 5}
            } 
            + 0^2}_{\colorbox{lime}{zwischenergebnis = 5}
        }
        + 1^2+ 2^2 + 3^2 + 4^2}_\text{\cl{zwischenergebnis} zum Ende der for-Schleife
    } 
     = \sum_{i = -2}^4 i^2
\end{align*}
Wir haben die Summe also genau so programmiert, wie wir sie als Mensch auch berechnen würden: Erst werden die ersten beiden Zahlen addiert, dann wird zum zwischenergebnis die nächste Zahl addiert, dann die nächste -- usw. -- bis wir alle Zahlen aufaddiert haben. 